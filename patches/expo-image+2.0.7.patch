diff --git a/node_modules/expo-image/android/build.gradle b/node_modules/expo-image/android/build.gradle
index 11492a2..b6bb941 100644
--- a/node_modules/expo-image/android/build.gradle
+++ b/node_modules/expo-image/android/build.gradle
@@ -44,7 +44,7 @@ dependencies {
   kapt "com.github.bumptech.glide:compiler:${GLIDE_VERSION}"
   api 'com.caverock:androidsvg-aar:1.4'
 
-  implementation "com.github.penfeizhou.android.animation:glide-plugin:3.0.2"
+  implementation("com.github.penfeizhou.android.animation:glide-plugin:3.0.3")
   implementation "com.github.bumptech.glide:avif-integration:${GLIDE_VERSION}"
 
   api 'com.github.bumptech.glide:okhttp3-integration:4.11.0'
diff --git a/node_modules/expo-image/android/src/main/java/expo/modules/image/okhttp/ExpoImageOkHttpClientGlideModule.kt b/node_modules/expo-image/android/src/main/java/expo/modules/image/okhttp/ExpoImageOkHttpClientGlideModule.kt
index 071907c..edf10c1 100644
--- a/node_modules/expo-image/android/src/main/java/expo/modules/image/okhttp/ExpoImageOkHttpClientGlideModule.kt
+++ b/node_modules/expo-image/android/src/main/java/expo/modules/image/okhttp/ExpoImageOkHttpClientGlideModule.kt
@@ -70,8 +70,15 @@ data class GlideUrlWrapper(val glideUrl: GlideUrl) {
 
 @GlideModule
 class ExpoImageOkHttpClientGlideModule : LibraryGlideModule() {
+  companion object {
+    var okHttpClient: OkHttpClient? = null
+  }
   override fun registerComponents(context: Context, glide: Glide, registry: Registry) {
-    val client = OkHttpClient()
+    val client = if (okHttpClient != null) {
+      okHttpClient!!
+    } else {
+      OkHttpClient()
+    }
     // We don't use the `GlideUrl` directly but we want to replace the default okhttp loader anyway
     // to make sure that the app will use only one client.
     registry.replace(GlideUrl::class.java, InputStream::class.java, OkHttpUrlLoader.Factory(client))
diff --git a/node_modules/expo-image/build/Image.d.ts b/node_modules/expo-image/build/Image.d.ts
index 44ea175..14b20d9 100644
--- a/node_modules/expo-image/build/Image.d.ts
+++ b/node_modules/expo-image/build/Image.d.ts
@@ -33,6 +33,16 @@ export declare class Image extends React.PureComponent<ImageProps> {
      * finished prefetching.
      */
     static prefetch(urls: string | string[], options?: ImagePrefetchOptions): Promise<boolean>;
+    /**
+     * Preloads images with detailed source information including cache keys.
+     * @param sources - An array of ImageSource objects with uri, cacheKey, cachePath, etc.
+     * @param options - Options for prefetching images.
+     * @return A promise resolving to `true` as soon as all images have been
+     * successfully prefetched. If an image fails to be prefetched, the promise
+     * will immediately resolve to `false` regardless of whether other images have
+     * finished prefetching.
+     */
+    static prefetch(sources: ImageSource[], options?: ImagePrefetchOptions): Promise<boolean>;
     /**
      * Asynchronously clears all images stored in memory.
      * @platform android
@@ -46,11 +56,13 @@ export declare class Image extends React.PureComponent<ImageProps> {
      * Asynchronously clears all images from the disk cache.
      * @platform android
      * @platform ios
+     * @param path Optional cache path to clear. If provided, only that specific cache is cleared.
+     *             If not provided, clears all caches.
      * @return A promise resolving to `true` when the operation succeeds.
      * It may resolve to `false` on Android when the activity is no longer available.
      * Resolves to `false` on Web.
      */
-    static clearDiskCache(): Promise<boolean>;
+    static clearDiskCache(path?: string): Promise<boolean>;
     /**
      * Asynchronously checks if an image exists in the disk cache and resolves to
      * the path of the cached image if it does.
diff --git a/node_modules/expo-image/build/Image.types.d.ts b/node_modules/expo-image/build/Image.types.d.ts
index 493fd68..1f71756 100644
--- a/node_modules/expo-image/build/Image.types.d.ts
+++ b/node_modules/expo-image/build/Image.types.d.ts
@@ -46,6 +46,14 @@ export type ImageSource = {
      * If not provided, the `uri` is used also as the cache key.
      */
     cacheKey?: string;
+    /**
+     * Custom cache subdirectory name for this image.
+     * Will be used as: Library/Caches/ImageCache/{cachePath}/
+     * If not provided, uses default cache location (SDImageCache.shared).
+     * @platform ios
+     * @example "server-abc123" or "external"
+     */
+    cachePath?: string;
     /**
      * The max width of the viewport for which this source should be selected.
      * Has no effect if `source` prop is not an array or has only 1 element.
diff --git a/node_modules/expo-image/ios/ExpoImage.podspec b/node_modules/expo-image/ios/ExpoImage.podspec
index 21bef71..d662d23 100644
--- a/node_modules/expo-image/ios/ExpoImage.podspec
+++ b/node_modules/expo-image/ios/ExpoImage.podspec
@@ -20,9 +20,7 @@ Pod::Spec.new do |s|
 
   s.dependency 'ExpoModulesCore'
   s.dependency 'SDWebImage', '~> 5.19.1'
-  s.dependency 'SDWebImageAVIFCoder', '~> 0.11.0'
   s.dependency 'SDWebImageSVGCoder', '~> 1.7.0'
-  s.dependency 'libavif/libdav1d'
 
   # Swift/Objective-C compatibility
   s.pod_target_xcconfig = {
diff --git a/node_modules/expo-image/ios/ImageLoader.swift b/node_modules/expo-image/ios/ImageLoader.swift
index a0dacf9..36a2908 100644
--- a/node_modules/expo-image/ios/ImageLoader.swift
+++ b/node_modules/expo-image/ios/ImageLoader.swift
@@ -14,7 +14,10 @@ internal final class ImageLoader {
   func load(_ source: ImageSource, maxSize: CGSize? = nil) async throws -> UIImage {
     // This loader uses only the disk cache. We may want to give more control on this, but the memory cache
     // doesn't make much sense for shared refs as they're kept in memory as long as their JS objects.
-    var context = createSDWebImageContext(forSource: source, cachePolicy: .disk)
+
+    // Get custom cache if cachePath is specified
+    let customCache = CachePathManager.shared.getCacheForPath(source.cachePath)
+    var context = createSDWebImageContext(forSource: source, cachePolicy: .disk, customCache: customCache)
 
     if let maxSize {
       context[.imageThumbnailPixelSize] = maxSize
diff --git a/node_modules/expo-image/ios/ImageModule.swift b/node_modules/expo-image/ios/ImageModule.swift
index 4bab386..4d9ca4f 100644
--- a/node_modules/expo-image/ios/ImageModule.swift
+++ b/node_modules/expo-image/ios/ImageModule.swift
@@ -2,7 +2,6 @@
 
 import ExpoModulesCore
 import SDWebImage
-import SDWebImageAVIFCoder
 import SDWebImageSVGCoder
 
 public final class ImageModule: Module {
@@ -150,6 +149,36 @@ public final class ImageModule: Module {
       }
     }
 
+    AsyncFunction("prefetchWithSources") { (sources: [ImageSource], cachePolicy: ImageCachePolicy, promise: Promise) in
+      var imagesLoaded = 0
+      var failed = false
+
+      sources.forEach { source in
+        var context = createSDWebImageContext(forSource: source, cachePolicy: cachePolicy)
+
+        // Override cache if cachePath is provided
+        let customCache = CachePathManager.shared.getCacheForPath(source.cachePath)
+        context[.imageCache] = customCache
+        context[.originalImageCache] = customCache
+
+        guard let url = source.uri else {
+          return
+        }
+
+        SDWebImagePrefetcher.shared.prefetchURLs([url], context: context, progress: nil, completed: { _, skipped in
+          if skipped > 0 && !failed {
+            failed = true
+            promise.resolve(false)
+          } else {
+            imagesLoaded = imagesLoaded + 1
+            if imagesLoaded == sources.count {
+              promise.resolve(true)
+            }
+          }
+        })
+      }
+    }
+
     AsyncFunction("generateBlurhashAsync") { (url: URL, numberOfComponents: CGSize, promise: Promise) in
       let downloader = SDWebImageDownloader()
       let parsedNumberOfComponents = (Int(numberOfComponents.width), Int(numberOfComponents.height))
@@ -170,9 +199,22 @@ public final class ImageModule: Module {
       return true
     }
 
-    AsyncFunction("clearDiskCache") { (promise: Promise) in
-      SDImageCache.shared.clearDisk {
-        promise.resolve(true)
+    AsyncFunction("clearDiskCache") { (cachePath: String?, promise: Promise) in
+      if let cachePath = cachePath, !cachePath.isEmpty {
+        // Clear specific cache path
+        if let cache = CachePathManager.shared.getCacheIfExists(cachePath) {
+          cache.clearDisk {
+            promise.resolve(true)
+          }
+        } else {
+          // Cache doesn't exist yet, nothing to clear
+          promise.resolve(true)
+        }
+      } else {
+        // Clear default shared cache
+        SDImageCache.shared.clearDisk {
+          promise.resolve(true)
+        }
       }
     }
 
@@ -211,7 +253,6 @@ public final class ImageModule: Module {
   static func registerCoders() {
     // By default Animated WebP is not supported
     SDImageCodersManager.shared.addCoder(SDImageAWebPCoder.shared)
-    SDImageCodersManager.shared.addCoder(SDImageAVIFCoder.shared)
     SDImageCodersManager.shared.addCoder(SDImageSVGCoder.shared)
     SDImageCodersManager.shared.addCoder(SDImageHEICCoder.shared)
   }
diff --git a/node_modules/expo-image/ios/ImageSource.swift b/node_modules/expo-image/ios/ImageSource.swift
index 88082fd..5025f0e 100644
--- a/node_modules/expo-image/ios/ImageSource.swift
+++ b/node_modules/expo-image/ios/ImageSource.swift
@@ -21,6 +21,9 @@ struct ImageSource: Record {
   @Field
   var cacheKey: String?
 
+  @Field
+  var cachePath: String?
+
   var pixelCount: Double {
     return width * height * scale * scale
   }
diff --git a/node_modules/expo-image/ios/ImageUtils.swift b/node_modules/expo-image/ios/ImageUtils.swift
index 34f2231..a58943e 100644
--- a/node_modules/expo-image/ios/ImageUtils.swift
+++ b/node_modules/expo-image/ios/ImageUtils.swift
@@ -172,7 +172,7 @@ func createCacheKeyFilter(_ cacheKey: String?) -> SDWebImageCacheKeyFilter? {
 /**
  Creates a default image context based on the source and the cache policy.
  */
-func createSDWebImageContext(forSource source: ImageSource, cachePolicy: ImageCachePolicy = .disk) -> SDWebImageContext {
+func createSDWebImageContext(forSource source: ImageSource, cachePolicy: ImageCachePolicy = .disk, customCache: SDImageCache? = nil) -> SDWebImageContext {
   var context = SDWebImageContext()
 
   // Modify URL request to add headers.
@@ -209,6 +209,12 @@ func createSDWebImageContext(forSource source: ImageSource, cachePolicy: ImageCa
   // Some loaders (e.g. blurhash) may need access to the source.
   context[ImageView.contextSourceKey] = source
 
+  // Override cache instances if custom cache is provided
+  if let customCache = customCache {
+    context[.imageCache] = customCache
+    context[.originalImageCache] = customCache
+  }
+
   return context
 }
 
diff --git a/node_modules/expo-image/ios/ImageView.swift b/node_modules/expo-image/ios/ImageView.swift
index 2ab4cba..7bbe66a 100644
--- a/node_modules/expo-image/ios/ImageView.swift
+++ b/node_modules/expo-image/ios/ImageView.swift
@@ -8,6 +8,83 @@ import VisionKit
 
 typealias SDWebImageContext = [SDWebImageContextOption: Any]
 
+// MARK: - Cache Path Management
+
+internal class CachePathManager {
+  static let shared = CachePathManager()
+
+  // Cache instances by path
+  private var caches: [String: SDImageCache] = [:]
+  private let lock = NSLock()
+
+  private init() {}
+
+  func getCacheForPath(_ cachePath: String?) -> SDImageCache {
+    // No cachePath provided -> use default singleton
+    guard let cachePath = cachePath, !cachePath.isEmpty else {
+      return SDImageCache.shared
+    }
+
+    lock.lock()
+    defer { lock.unlock() }
+
+    // Return existing cache for this path
+    if let existing = caches[cachePath] {
+      return existing
+    }
+
+    // Create base ImageCache directory
+    guard let cachesDir = FileManager.default.urls(
+      for: .cachesDirectory,
+      in: .userDomainMask
+    ).first else {
+      return SDImageCache.shared
+    }
+
+    // Build path: Library/Caches/ImageCache/{cachePath}/
+    let imageCacheDir = cachesDir
+      .appendingPathComponent("ImageCache")
+      .appendingPathComponent(cachePath)
+
+    // Create new cache instance for this path
+    let cache = SDImageCache(
+      namespace: "custom",
+      diskCacheDirectory: imageCacheDir.path
+    )
+    caches[cachePath] = cache
+
+    #if DEBUG
+    print("[expo-image] Created cache at: \(imageCacheDir.path)")
+    #endif
+
+    return cache
+  }
+
+  func getCacheIfExists(_ cachePath: String) -> SDImageCache? {
+    lock.lock()
+    defer { lock.unlock() }
+    return caches[cachePath]
+  }
+
+  func clearAllCaches(completion: @escaping () -> Void) {
+    lock.lock()
+    let allCaches = Array(caches.values)
+    lock.unlock()
+
+    let group = DispatchGroup()
+    for cache in allCaches {
+      group.enter()
+      cache.clearDisk {
+        group.leave()
+      }
+    }
+
+    group.notify(queue: .main) {
+      completion()
+    }
+  }
+}
+
 // swiftlint:disable:next type_body_length
 public final class ImageView: ExpoView {
   static let contextSourceKey = SDWebImageContextOption(rawValue: "source")
@@ -129,7 +206,10 @@ public final class ImageView: ExpoView {
     if sdImageView.image == nil {
       sdImageView.contentMode = contentFit.toContentMode()
     }
-    var context = createSDWebImageContext(forSource: source, cachePolicy: cachePolicy)
+
+    // Get custom cache if cachePath is specified
+    let customCache = CachePathManager.shared.getCacheForPath(source.cachePath)
+    var context = createSDWebImageContext(forSource: source, cachePolicy: cachePolicy, customCache: customCache)
 
     // Cancel currently running load requests.
     cancelPendingOperation()
@@ -311,7 +391,8 @@ public final class ImageView: ExpoView {
     // to cache them or apply the same policy as with the proper image?
     // Basically they are also cached in memory as the `placeholderImage` property,
     // so just `disk` policy sounds like a good idea.
-    var context = createSDWebImageContext(forSource: placeholder, cachePolicy: .disk)
+    let customCache = CachePathManager.shared.getCacheForPath(placeholder.cachePath)
+    var context = createSDWebImageContext(forSource: placeholder, cachePolicy: .disk, customCache: customCache)
 
     let isPlaceholderHash = placeholder.isBlurhash || placeholder.isThumbhash
 
diff --git a/node_modules/expo-image/src/Image.tsx b/node_modules/expo-image/src/Image.tsx
index 7721bd9..ee5a1b1 100644
--- a/node_modules/expo-image/src/Image.tsx
+++ b/node_modules/expo-image/src/Image.tsx
@@ -69,8 +69,18 @@ export class Image extends React.PureComponent<ImageProps> {
    * finished prefetching.
    */
   static async prefetch(urls: string | string[], options?: ImagePrefetchOptions): Promise<boolean>;
+  /**
+   * Preloads images with detailed source information including cache keys.
+   * @param sources - An array of ImageSource objects with uri, cacheKey, cachePath, etc.
+   * @param options - Options for prefetching images.
+   * @return A promise resolving to `true` as soon as all images have been
+   * successfully prefetched. If an image fails to be prefetched, the promise
+   * will immediately resolve to `false` regardless of whether other images have
+   * finished prefetching.
+   */
+  static async prefetch(sources: ImageSource[], options?: ImagePrefetchOptions): Promise<boolean>;
   static async prefetch(
-    urls: string | string[],
+    urlsOrSources: string | string[] | ImageSource[],
     options?: ImagePrefetchOptions['cachePolicy'] | ImagePrefetchOptions
   ): Promise<boolean> {
     let cachePolicy: ImagePrefetchOptions['cachePolicy'] = 'memory-disk';
@@ -85,7 +95,18 @@ export class Image extends React.PureComponent<ImageProps> {
         break;
     }
 
-    return ImageModule.prefetch(Array.isArray(urls) ? urls : [urls], cachePolicy, headers);
+    // Normalize input to array
+    const sources = Array.isArray(urlsOrSources) ? urlsOrSources : [urlsOrSources];
+
+    // Check if we have ImageSource objects or plain strings
+    const firstItem = sources[0];
+    if (typeof firstItem === 'string') {
+      // Legacy behavior: plain URL strings
+      return ImageModule.prefetch(sources as string[], cachePolicy, headers);
+    } else {
+      // New behavior: ImageSource objects with cacheKey and cachePath per image
+      return ImageModule.prefetchWithSources(sources as ImageSource[], cachePolicy);
+    }
   }
 
   /**
diff --git a/node_modules/expo-image/src/Image.types.ts b/node_modules/expo-image/src/Image.types.ts
index 63445be..56160e9 100644
--- a/node_modules/expo-image/src/Image.types.ts
+++ b/node_modules/expo-image/src/Image.types.ts
@@ -51,6 +51,14 @@ export type ImageSource = {
    * If not provided, the `uri` is used also as the cache key.
    */
   cacheKey?: string;
+  /**
+   * Custom cache subdirectory name for this image.
+   * Will be used as: Library/Caches/ImageCache/{cachePath}/
+   * If not provided, uses default cache location (SDImageCache.shared).
+   * @platform ios
+   * @example "server-abc123" or "external"
+   */
+  cachePath?: string;
   /**
    * The max width of the viewport for which this source should be selected.
    * Has no effect if `source` prop is not an array or has only 1 element.
